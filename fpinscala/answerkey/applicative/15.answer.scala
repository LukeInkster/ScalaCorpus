It's because `foldRight`, `foldLeft`, and `foldMap` don't give us any way of constructing a value of the foldable type. In order to `map` over a structure, you need the ability to create a new structure (such as `Nil` and `Cons` in the case of a `List`). `Traverse` is able to extend `Functor` precisely because a traversal preserves the original structure. 
An example of a Foldable that is not a functor:

    case class Iteration[A](a: A, f: A => A, n: Int) {
      def foldMap[B](g: A => B)(M: Monoid[B]): B = {
        def iterate(n: Int, b: B, c: A): B =
          if (n <= 0) b else iterate(n-1, g(c), f(a))
        iterate(n, M.zero, a)
      }
    }

This class conceptually represents a sequence of `A` values, generated by repeated function application starting from some seed value. But can you see why it's not possible to define `map` for this type?